## API Report File for "@datastax/astra-db-ts"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import BigNumber from 'bignumber.js';
import type TypedEmitter from 'typed-emitter';
import type TypedEventEmitter from 'typed-emitter';

// @public (undocumented)
export const $DeserializeForCollection: unique symbol;

// @public (undocumented)
export const $DeserializeForTable: unique symbol;

// @public (undocumented)
export const $SerializeForCollection: unique symbol;

// @public (undocumented)
export const $SerializeForTable: unique symbol;

// @public
export interface AddColumnOperation {
    columns: CreateTableColumnDefinitions;
}

// @public
export interface AddVectorizeOperation<Schema extends SomeRow> {
    columns: Partial<Record<keyof Schema, VectorizeServiceOptions>>;
}

// @public
export abstract class AdminCommandEvent extends DataAPIClientEvent {
    // Warning: (ae-forgotten-export) The symbol "DevOpsAPIRequestInfo" needs to be exported by the entry point index.d.ts
    //
    // @internal
    protected constructor(name: string, info: DevOpsAPIRequestInfo, longRunning: boolean);
    // @internal (undocumented)
    protected _desc(): string;
    readonly longRunning: boolean;
    readonly method: 'GET' | 'POST' | 'DELETE';
    readonly methodName: string;
    readonly params?: Record<string, any>;
    readonly path: string;
    readonly reqBody?: Record<string, any>;
}

// @public
export type AdminCommandEventMap = {
    adminCommandStarted: (event: AdminCommandStartedEvent) => void;
    adminCommandPolling: (event: AdminCommandPollingEvent) => void;
    adminCommandSucceeded: (event: AdminCommandSucceededEvent) => void;
    adminCommandFailed: (event: AdminCommandFailedEvent) => void;
    adminCommandWarnings: (event: AdminCommandWarningsEvent) => void;
};

// @public
export class AdminCommandFailedEvent extends AdminCommandEvent {
    // @internal
    constructor(info: DevOpsAPIRequestInfo, longRunning: boolean, error: Error, started: number);
    readonly duration: number;
    readonly error: Error;
    formatted(): string;
}

// @public
export class AdminCommandPollingEvent extends AdminCommandEvent {
    // @internal
    constructor(info: DevOpsAPIRequestInfo, started: number, interval: number, pollCount: number);
    readonly elapsed: number;
    formatted(): string;
    readonly interval: number;
    readonly pollCount: number;
}

// @public
export class AdminCommandStartedEvent extends AdminCommandEvent {
    // @internal
    constructor(info: DevOpsAPIRequestInfo, longRunning: boolean, timeout: Partial<TimeoutDescriptor>);
    formatted(): string;
    readonly timeout: Partial<TimeoutDescriptor>;
}

// @public
export class AdminCommandSucceededEvent extends AdminCommandEvent {
    // @internal
    constructor(info: DevOpsAPIRequestInfo, longRunning: boolean, data: Record<string, any> | undefined, started: number);
    readonly duration: number;
    formatted(): string;
    readonly resBody?: Record<string, any>;
}

// @public
export class AdminCommandWarningsEvent extends AdminCommandEvent {
    // @internal
    constructor(info: DevOpsAPIRequestInfo, longRunning: boolean, warnings: DataAPIErrorDescriptor[]);
    formatted(): string;
    readonly warnings: DataAPIErrorDescriptor[];
}

// @public
export interface AdminOptions {
    additionalHeaders?: Record<string, string>;
    adminToken?: string | TokenProvider | null;
    astraEnv?: 'dev' | 'prod' | 'test';
    endpointUrl?: string;
    logging?: DataAPILoggingConfig;
    timeoutDefaults?: Partial<TimeoutDescriptor>;
}

// @public
export interface AlterTableOperations<Schema extends SomeRow> {
    // (undocumented)
    add?: AddColumnOperation;
    // (undocumented)
    addVectorize?: AddVectorizeOperation<Schema>;
    // (undocumented)
    drop?: DropColumnOperation<Schema>;
    // (undocumented)
    dropVectorize?: DropVectorizeOperation<Schema>;
}

// @public
export interface AlterTableOptions<Schema extends SomeRow> extends WithTimeout<'tableAdminTimeoutMs'> {
    operation: AlterTableOperations<Schema>;
}

// @public
export class AstraAdmin {
    // Warning: (ae-forgotten-export) The symbol "InternalRootClientOpts" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor(rootOpts: InternalRootClientOpts, rawAdminOpts?: AdminOptions);
    createDatabase(config: AstraDatabaseConfig, options?: CreateAstraDatabaseOptions): Promise<AstraDbAdmin>;
    db(endpoint: string, options?: DbOptions): Db;
    db(id: string, region: string, options?: DbOptions): Db;
    dbAdmin(endpoint: string, options?: DbOptions): AstraDbAdmin;
    dbAdmin(id: string, region: string, options?: DbOptions): AstraDbAdmin;
    dbInfo(id: string, options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<AstraDbAdminInfo>;
    dropDatabase(db: Db | string, options?: AstraDropDatabaseOptions): Promise<void>;
    // (undocumented)
    get _httpClient(): OpaqueHttpClient;
    listDatabases(options?: ListAstraDatabasesOptions): Promise<AstraDbAdminInfo[]>;
}

// @public
export type AstraAdminBlockingOptions = AstraPollBlockingOptions | AstraNoBlockingOptions;

// @public
export type AstraCreateKeyspaceOptions = AstraAdminBlockingOptions & WithTimeout<'keyspaceAdminTimeoutMs'> & {
    updateDbKeyspace?: boolean;
};

// @public
export interface AstraDatabaseConfig {
    cloudProvider?: AstraDbCloudProvider;
    keyspace?: string;
    name: string;
    region: string;
}

// @public
export class AstraDbAdmin extends DbAdmin {
    // @internal
    constructor(db: Db, rootOpts: InternalRootClientOpts, rawAdminOpts: AdminOptions | undefined, dbToken: TokenProvider | undefined, endpoint: string);
    createKeyspace(keyspace: string, options?: AstraCreateKeyspaceOptions): Promise<void>;
    db(): Db;
    drop(options?: AstraDropKeyspaceOptions): Promise<void>;
    dropKeyspace(keyspace: string, options?: AstraDropKeyspaceOptions): Promise<void>;
    findEmbeddingProviders(options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<FindEmbeddingProvidersResult>;
    // (undocumented)
    get _httpClient(): OpaqueHttpClient;
    get id(): string;
    info(options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<AstraDbAdminInfo>;
    listKeyspaces(options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<string[]>;
}

// @public
export interface AstraDbAdminInfo extends BaseAstraDbInfo {
    createdAt: Date;
    lastUsed: Date;
    orgId: string;
    ownerId: string;
    regions: AstraDbRegionInfo[];
}

// @public
export type AstraDbCloudProvider = 'AWS' | 'GCP' | 'AZURE';

// @public
export type AstraDbCloudProviderFilter = AstraDbCloudProvider | 'ALL';

// @public
export interface AstraDbInfo extends BaseAstraDbInfo {
    // (undocumented)
    apiEndpoint: string;
    // (undocumented)
    region: string;
}

// @public
export interface AstraDbRegionInfo {
    apiEndpoint: string;
    createdAt: Date;
    name: string;
}

// @public
export type AstraDbStatus = 'ACTIVE' | 'ERROR' | 'DECOMMISSIONING' | 'DEGRADED' | 'HIBERNATED' | 'HIBERNATING' | 'INITIALIZING' | 'MAINTENANCE' | 'PARKED' | 'PARKING' | 'PENDING' | 'PREPARED' | 'PREPARING' | 'RESIZING' | 'RESUMING' | 'TERMINATED' | 'TERMINATING' | 'UNKNOWN' | 'UNPARKING' | 'SYNCHRONIZING';

// @public
export type AstraDbStatusFilter = AstraDbStatus | 'ALL' | 'NONTERMINATED';

// @public
export type AstraDropDatabaseOptions = AstraAdminBlockingOptions & WithTimeout<'databaseAdminTimeoutMs'>;

// @public
export type AstraDropKeyspaceOptions = AstraAdminBlockingOptions & WithTimeout<'keyspaceAdminTimeoutMs'>;

// @public
export interface AstraNoBlockingOptions {
    blocking: false;
}

// @public
export interface AstraPollBlockingOptions {
    blocking?: true;
    pollInterval?: number;
}

// @public
export class AWSEmbeddingHeadersProvider extends EmbeddingHeadersProvider {
    constructor(accessKeyId: string, secretAccessKey: string);
    getHeaders(): Record<string, string>;
}

// @public
export interface BaseAstraDbInfo {
    cloudProvider: AstraDbCloudProvider;
    environment: 'dev' | 'test' | 'prod';
    id: string;
    keyspaces: string[];
    name: string;
    raw: Record<string, any>;
    status: AstraDbStatus;
}

// @public (undocumented)
export interface BaseDesCtx<Fns extends CodecSerDesFns> extends BaseSerDesCtx<Fns> {
    // (undocumented)
    keys: string[] | null;
    // (undocumented)
    parsingInsertedId: boolean;
    // (undocumented)
    rawDataApiResp: RawDataAPIResponse;
}

// @public (undocumented)
export interface BaseSerCtx<Fns extends CodecSerDesFns> extends BaseSerDesCtx<Fns> {
    // (undocumented)
    mutatingInPlace: boolean;
}

// @public (undocumented)
export interface BaseSerDesConfig<Fns extends CodecSerDesFns, SerCtx extends BaseSerCtx<Fns>, DesCtx extends BaseDesCtx<Fns>> {
    // (undocumented)
    codecs?: RawCodec<Fns>[];
    // (undocumented)
    deserialize?: OneOrMany<SerDesFn<DesCtx>>;
    // (undocumented)
    keyTransformer?: KeyTransformer;
    // (undocumented)
    mutateInPlace?: boolean;
    // (undocumented)
    serialize?: OneOrMany<SerDesFn<SerCtx>>;
}

// @public (undocumented)
export interface BaseSerDesCtx<Fns extends CodecSerDesFns> {
    // (undocumented)
    codecs: Codecs<Fns>;
    // (undocumented)
    continue(): readonly [2];
    // (undocumented)
    done<T>(obj?: T): readonly [0, T?];
    // (undocumented)
    keyTransformer?: KeyTransformer;
    // (undocumented)
    next<T>(obj?: T): readonly [1, T?];
    // (undocumented)
    path: string[];
    // (undocumented)
    rootObj: SomeDoc;
}

// @public
export const blob: (blob: DataAPIBlobLike) => DataAPIBlob;

// @public
export type Caller = readonly [name: string, version?: string];

// @public (undocumented)
export class Camel2SnakeCase extends KeyTransformer {
    // (undocumented)
    deserializeKey(snake: string, ctx: BaseDesCtx<CodecSerDesFns>): string;
    // (undocumented)
    serializeKey(camel: string, ctx: BaseSerCtx<CodecSerDesFns>): string;
}

// @public (undocumented)
export type ClassGuardCodec<Fns extends CodecSerDesFns> = Fns & {
    type: string;
    serializeClass: new (...args: any[]) => any;
};

// @public (undocumented)
export type CodecOpts<Fns extends CodecSerDesFns, SerCtx, DesCtx> = (Fns & {
    serializeGuard: (value: unknown, ctx: SerCtx) => boolean;
    deserializeGuard?: (value: unknown, ctx: DesCtx) => boolean;
}) | (Fns & {
    serializeClass: new (...args: any[]) => any;
    deserializeGuard?: (value: unknown, ctx: DesCtx) => boolean;
}) | Pick<Fns, 'deserialize'>;

// @public (undocumented)
export interface Codecs<Fns extends CodecSerDesFns> {
    // (undocumented)
    classGuard: ClassGuardCodec<Fns>[];
    // (undocumented)
    customGuard: CustomGuardCodec<Fns>[];
    // (undocumented)
    name: Record<string, NameCodec<Fns>>;
    // (undocumented)
    path: PathCodec<Fns>[];
    // (undocumented)
    type: Record<string, TypeCodec<Fns>>;
}

// @public (undocumented)
export type CodecSerDesFns = Record<'serialize' | 'deserialize', (...args: any[]) => ReturnType<SerDesFn<any>>>;

// @public (undocumented)
export type CollCodec<_Class extends CollCodecClass> = EmptyObj;

// @public (undocumented)
export interface CollCodecClass {
    // (undocumented)
    [$DeserializeForCollection]: CollCodecSerDesFns['deserialize'];
    // (undocumented)
    new (...args: any[]): {
        [$SerializeForCollection]: (ctx: CollSerCtx) => ReturnType<SerDesFn<any>>;
    };
}

// @public (undocumented)
export class CollCodecs {
    // (undocumented)
    static Defaults: {
        $date: RawCodec<CollCodecSerDesFns>;
        $vector: RawCodec<CollCodecSerDesFns>;
        $uuid: RawCodec<CollCodecSerDesFns>;
        $objectId: RawCodec<CollCodecSerDesFns>;
    };
    // (undocumented)
    static forName(name: string, optsOrClass: CodecOpts<CollCodecSerDesFns, CollSerCtx, CollDesCtx> | CollCodecClass): RawCodec<CollCodecSerDesFns>;
    // (undocumented)
    static forPath(path: string[], optsOrClass: CodecOpts<CollCodecSerDesFns, CollSerCtx, CollDesCtx> | CollCodecClass): RawCodec<CollCodecSerDesFns>;
    // (undocumented)
    static forType(type: string, optsOrClass: CodecOpts<CollCodecSerDesFns, CollSerCtx, CollDesCtx> | CollCodecClass): RawCodec<CollCodecSerDesFns>;
}

// @public (undocumented)
export interface CollCodecSerDesFns {
    // (undocumented)
    deserialize: SerDesFn<CollDesCtx>;
    // (undocumented)
    serialize: SerDesFn<CollSerCtx>;
}

// @public (undocumented)
export interface CollDesCtx extends BaseDesCtx<CollCodecSerDesFns> {
    // (undocumented)
    getNumRepForPath?: GetCollNumRepFn;
}

// @public
export class Collection<WSchema extends SomeDoc = SomeDoc, RSchema extends WithId<SomeDoc> = FoundDoc<WSchema>> {
    // Warning: (ae-forgotten-export) The symbol "DataAPIHttpClient" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor(db: Db, httpClient: DataAPIHttpClient, name: string, opts: CollectionOptions | undefined);
    countDocuments(filter: CollectionFilter<WSchema>, upperBound: number, options?: WithTimeout<'generalMethodTimeoutMs'>): Promise<number>;
    deleteMany(filter: CollectionFilter<WSchema>, options?: WithTimeout<'generalMethodTimeoutMs'>): Promise<CollectionDeleteManyResult>;
    deleteOne(filter: CollectionFilter<WSchema>, options?: CollectionDeleteOneOptions): Promise<CollectionDeleteOneResult>;
    distinct<Key extends string>(key: Key, filter: CollectionFilter<WSchema>, options?: WithTimeout<'generalMethodTimeoutMs'>): Promise<Flatten<(SomeDoc & ToDotNotation<RSchema>)[Key]>[]>;
    drop(options?: WithTimeout<'collectionAdminTimeoutMs'>): Promise<void>;
    estimatedDocumentCount(options?: WithTimeout<'generalMethodTimeoutMs'>): Promise<number>;
    find(filter: CollectionFilter<WSchema>, options?: CollectionFindOptions & {
        projection?: never;
    }): CollectionFindCursor<WithSim<RSchema>, WithSim<RSchema>>;
    find<TRaw extends SomeDoc = Partial<RSchema>>(filter: CollectionFilter<WSchema>, options: CollectionFindOptions): CollectionFindCursor<TRaw, TRaw>;
    findOne(filter: CollectionFilter<WSchema>, options?: CollectionFindOneOptions & {
        projection?: never;
    }): Promise<WithSim<RSchema> | null>;
    findOne<TRaw extends SomeDoc = Partial<RSchema>>(filter: CollectionFilter<WSchema>, options: CollectionFindOneOptions): Promise<TRaw | null>;
    findOneAndDelete<TRaw extends SomeDoc = RSchema>(filter: CollectionFilter<WSchema>, options?: CollectionFindOneAndDeleteOptions): Promise<TRaw | null>;
    findOneAndReplace<TRaw extends SomeDoc = RSchema>(filter: CollectionFilter<WSchema>, replacement: NoId<WSchema>, options?: CollectionFindOneAndReplaceOptions): Promise<TRaw | null>;
    findOneAndUpdate(filter: CollectionFilter<WSchema>, update: CollectionUpdateFilter<WSchema>, options?: CollectionFindOneAndUpdateOptions): Promise<RSchema | null>;
    get _httpClient(): OpaqueHttpClient;
    insertMany(documents: readonly MaybeId<WSchema>[], options?: CollectionInsertManyOptions): Promise<CollectionInsertManyResult<RSchema>>;
    insertOne(document: MaybeId<WSchema>, options?: WithTimeout<'generalMethodTimeoutMs'>): Promise<CollectionInsertOneResult<RSchema>>;
    readonly keyspace: string;
    readonly name: string;
    options(options?: WithTimeout<'collectionAdminTimeoutMs'>): Promise<CollectionDefinition<SomeDoc>>;
    replaceOne(filter: CollectionFilter<WSchema>, replacement: NoId<WSchema>, options?: CollectionReplaceOneOptions): Promise<CollectionReplaceOneResult<RSchema>>;
    updateMany(filter: CollectionFilter<WSchema>, update: CollectionUpdateFilter<WSchema>, options?: CollectionUpdateManyOptions): Promise<CollectionUpdateManyResult<RSchema>>;
    updateOne(filter: CollectionFilter<WSchema>, update: CollectionUpdateFilter<WSchema>, options?: CollectionUpdateOneOptions): Promise<CollectionUpdateOneResult<RSchema>>;
}

// @public
export interface CollectionArrayFilterOps<Elem> {
    $all?: Elem;
    $size?: number;
}

// Warning: (ae-forgotten-export) The symbol "PickArrayTypes" needs to be exported by the entry point index.d.ts
//
// @public
export type CollectionArrayUpdate<Schema> = {
    [K in keyof Schema as any[] extends Schema[K] ? K : never]?: PickArrayTypes<Schema[K]>;
};

// @public
export type CollectionCurrentDate<Schema> = {
    [K in keyof Schema as Schema[K] extends Date | {
        $date: number;
    } ? K : never]?: boolean;
};

// Warning: (ae-forgotten-export) The symbol "ContainsDate" needs to be exported by the entry point index.d.ts
//
// @public
export type CollectionDateUpdate<Schema> = {
    [K in keyof Schema as ContainsDate<Schema[K]> extends true ? K : never]?: Date | {
        $date: number;
    };
};

// @public
export interface CollectionDefaultIdOptions {
    type: 'uuid' | 'uuidv6' | 'uuidv7' | 'objectId';
}

// @public
export interface CollectionDefinition<Schema extends SomeDoc> {
    defaultId?: CollectionDefaultIdOptions;
    indexing?: CollectionIndexingOptions<Schema>;
    vector?: CollectionVectorOptions;
}

// @public
export class CollectionDeleteManyError extends CumulativeOperationError {
    name: string;
    readonly partialResult: CollectionDeleteManyResult;
}

// @public
export type CollectionDeleteManyResult = GenericDeleteManyResult;

// @public
export type CollectionDeleteOneOptions = GenericDeleteOneOptions;

// @public
export interface CollectionDeleteOneResult {
    deletedCount: 0 | 1;
}

// @public
export interface CollectionDescriptor {
    definition: CollectionDefinition<SomeDoc>;
    name: string;
}

// @public
export type CollectionFilter<Schema extends SomeDoc> = {
    [K in keyof ToDotNotation<NoId<Schema>>]?: CollectionFilterExpr<ToDotNotation<NoId<Schema>>[K]>;
} & {
    _id?: CollectionFilterExpr<IdOf<Schema>>;
    $and?: CollectionFilter<Schema>[];
    $or?: CollectionFilter<Schema>[];
    $not?: CollectionFilter<Schema>;
    [key: string]: any;
};

// @public
export type CollectionFilterExpr<Elem> = Elem | (CollectionFilterOps<Elem> & {
    [key: string]: any;
});

// @public
export type CollectionFilterOps<Elem> = {
    $eq?: Elem;
    $ne?: Elem;
    $in?: Elem[];
    $nin?: Elem[];
    $exists?: boolean;
    $lt?: Elem;
    $lte?: Elem;
    $gt?: Elem;
    $gte?: Elem;
} & (any[] extends Elem ? CollectionArrayFilterOps<Elem> : EmptyObj);

// @public
export class CollectionFindCursor<T, TRaw extends SomeDoc = SomeDoc> extends FindCursor<T, TRaw> {
    get dataSource(): Collection;
    filter(filter: CollectionFilter<TRaw>): FindCursor<T, TRaw>;
}

// @public
export type CollectionFindOneAndDeleteOptions = GenericFindOneAndDeleteOptions;

// @public
export type CollectionFindOneAndReplaceOptions = GenericFindOneAndReplaceOptions;

// @public
export type CollectionFindOneAndUpdateOptions = GenericFindOneAndUpdateOptions;

// @public
export type CollectionFindOneOptions = GenericFindOneOptions;

// @public
export type CollectionFindOptions = GenericFindOptions;

// @public
export type CollectionIndexingOptions<Schema extends SomeDoc> = {
    allow: (keyof ToDotNotation<Schema> | string)[] | ['*'];
    deny?: never;
} | {
    deny: (keyof ToDotNotation<Schema> | string)[] | ['*'];
    allow?: never;
};

// @public
export class CollectionInsertManyError extends CumulativeOperationError {
    name: string;
    readonly partialResult: CollectionInsertManyResult<SomeDoc>;
}

// @public
export type CollectionInsertManyOptions = GenericInsertManyOptions;

// @public
export interface CollectionInsertManyResult<RSchema> {
    insertedCount: number;
    insertedIds: IdOf<RSchema>[];
}

// @public
export interface CollectionInsertOneResult<RSchema> {
    insertedId: IdOf<RSchema>;
}

// Warning: (ae-forgotten-export) The symbol "IsNum" needs to be exported by the entry point index.d.ts
//
// @public
export type CollectionNumberUpdate<Schema> = {
    [K in keyof Schema as IsNum<Schema[K]> extends true ? K : never]?: number | bigint;
};

// @public
export interface CollectionOptions extends WithKeyspace {
    embeddingApiKey?: string | EmbeddingHeadersProvider | null;
    logging?: DataAPILoggingConfig;
    // @beta
    serdes?: CollectionSerDesConfig;
    timeoutDefaults?: Partial<TimeoutDescriptor>;
}

// @public
export type CollectionPop<Schema> = {
    [K in keyof CollectionArrayUpdate<Schema>]?: number;
};

// @public
export type CollectionPush<Schema> = {
    [K in keyof CollectionArrayUpdate<Schema>]?: (CollectionArrayUpdate<Schema>[K] | {
        $each: CollectionArrayUpdate<Schema>[K][];
        $position?: number;
    });
};

// @public
export type CollectionReplaceOneOptions = GenericReplaceOneOptions;

// @public
export type CollectionReplaceOneResult<RSchema> = GenericUpdateResult<IdOf<RSchema>, 0 | 1>;

// @public (undocumented)
export interface CollectionSerDesConfig extends BaseSerDesConfig<CollCodecSerDesFns, CollSerCtx, CollDesCtx> {
    // (undocumented)
    enableBigNumbers?: GetCollNumRepFn | CollNumRepCfg;
}

// @public
export interface CollectionUpdateFilter<Schema extends SomeDoc> {
    $addToSet?: CollectionPush<Schema> & SomeDoc;
    $currentDate?: CollectionCurrentDate<Schema> & Record<string, boolean>;
    $inc?: CollectionNumberUpdate<Schema> & Record<string, number>;
    $max?: (CollectionNumberUpdate<Schema> | CollectionDateUpdate<Schema>) & Record<string, number | bigint | Date | {
        $date: number;
    }>;
    $min?: (CollectionNumberUpdate<Schema> | CollectionDateUpdate<Schema>) & Record<string, number | bigint | Date | {
        $date: number;
    }>;
    $mul?: CollectionNumberUpdate<Schema> & Record<string, number>;
    $pop?: CollectionPop<Schema> & Record<string, number>;
    $push?: CollectionPush<Schema> & SomeDoc;
    $rename?: Record<string, string>;
    $set?: Partial<Schema> & SomeDoc;
    $setOnInsert?: Partial<Schema> & SomeDoc;
    $unset?: Record<string, '' | true | 1>;
}

// @public
export class CollectionUpdateManyError extends CumulativeOperationError {
    name: string;
    readonly partialResult: CollectionUpdateManyResult<SomeDoc>;
}

// @public
export type CollectionUpdateManyOptions = GenericUpdateManyOptions;

// @public
export type CollectionUpdateManyResult<RSchema> = GenericUpdateResult<IdOf<RSchema>, number>;

// @public
export type CollectionUpdateOneOptions = GenericUpdateOneOptions;

// @public
export type CollectionUpdateOneResult<RSchema> = GenericUpdateResult<IdOf<RSchema>, 0 | 1>;

// @public
export interface CollectionVectorOptions {
    dimension?: number;
    metric?: 'cosine' | 'euclidean' | 'dot_product';
    service?: VectorizeServiceOptions;
    sourceModel?: string;
}

// @public (undocumented)
export type CollNumRep = 'number' | 'bigint' | 'bignumber' | 'string' | 'number_or_string';

// @public (undocumented)
export type CollNumRepCfg = Record<string, CollNumRep>;

// @public (undocumented)
export interface CollSerCtx extends BaseSerCtx<CollCodecSerDesFns> {
    // (undocumented)
    bigNumsEnabled: boolean;
}

// @public
export abstract class CommandEvent extends DataAPIClientEvent {
    // Warning: (ae-forgotten-export) The symbol "DataAPIRequestInfo" needs to be exported by the entry point index.d.ts
    //
    // @internal
    protected constructor(name: string, info: DataAPIRequestInfo);
    readonly command: Record<string, any>;
    readonly commandName: string;
    // @internal (undocumented)
    protected _desc(): string;
    readonly keyspace: string;
    readonly source?: string;
    readonly url: string;
}

// @public
export type CommandEventMap = {
    commandStarted: (event: CommandStartedEvent) => void;
    commandSucceeded: (event: CommandSucceededEvent) => void;
    commandFailed: (event: CommandFailedEvent) => void;
    commandWarnings: (event: CommandWarningsEvent) => void;
};

// @public
export class CommandFailedEvent extends CommandEvent {
    // @internal
    constructor(info: DataAPIRequestInfo, error: Error, started: number);
    readonly duration: number;
    readonly error: Error;
    formatted(): string;
}

// @public
export class CommandStartedEvent extends CommandEvent {
    // @internal
    constructor(info: DataAPIRequestInfo);
    formatted(): string;
    readonly timeout: Partial<TimeoutDescriptor>;
}

// @public
export class CommandSucceededEvent extends CommandEvent {
    // @internal
    constructor(info: DataAPIRequestInfo, reply: RawDataAPIResponse, started: number);
    readonly duration: number;
    formatted(): string;
    readonly resp?: RawDataAPIResponse;
}

// @public
export class CommandWarningsEvent extends CommandEvent {
    // @internal
    constructor(info: DataAPIRequestInfo, warnings: DataAPIErrorDescriptor[]);
    formatted(): string;
    readonly warnings: DataAPIErrorDescriptor[];
}

// Warning: (ae-forgotten-export) The symbol "CqlNonGenericType2TSTypeDict" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "CqlGenericType2TSTypeDict" needs to be exported by the entry point index.d.ts
//
// @public
export type CqlType2TSType<T extends string, Def> = T extends keyof CqlNonGenericType2TSTypeDict ? CqlNonGenericType2TSTypeDict[T] : T extends keyof CqlGenericType2TSTypeDict<Def> ? CqlGenericType2TSTypeDict<Def>[T] : unknown;

// @public
export type CreateAstraDatabaseOptions = AstraAdminBlockingOptions & WithTimeout<'databaseAdminTimeoutMs'> & {
    dbOptions?: DbOptions;
};

// @public
export interface CreateCollectionOptions<Schema extends SomeDoc> extends CollectionDefinition<Schema>, CollectionOptions {
    // (undocumented)
    timeout?: number | Pick<Partial<TimeoutDescriptor>, 'collectionAdminTimeoutMs'>;
}

// @public
export type CreateTableColumnDefinitions = Record<string, LooseCreateTableColumnDefinition | StrictCreateTableColumnDefinition>;

// @public
export interface CreateTableDefinition {
    readonly columns: CreateTableColumnDefinitions;
    readonly primaryKey: CreateTablePrimaryKeyDefinition;
}

// @public
export interface CreateTableIndexOptions extends WithTimeout<'tableAdminTimeoutMs'> {
    ifNotExists?: boolean;
    options?: TableIndexOptions;
}

// @public
export interface CreateTableOptions<Def extends CreateTableDefinition = CreateTableDefinition> extends WithTimeout<'tableAdminTimeoutMs'>, TableOptions {
    // (undocumented)
    definition: Def;
    // (undocumented)
    ifNotExists?: boolean;
}

// @public
export type CreateTablePrimaryKeyDefinition = string | FullCreateTablePrimaryKeyDefinition;

// @public
export interface CreateTableVectorIndexOptions extends WithTimeout<'tableAdminTimeoutMs'> {
    ifNotExists?: boolean;
    options?: TableVectorIndexOptions;
}

// @public
export abstract class CumulativeOperationError extends DataAPIResponseError {
    readonly partialResult: unknown;
}

// @public
export class CursorError extends DataAPIError {
    // @internal
    constructor(message: string, cursor: FindCursor<unknown>);
    readonly cursor: FindCursor<unknown>;
    readonly state: FindCursorStatus;
}

// @public (undocumented)
export type CustomGuardCodec<Fns extends CodecSerDesFns> = Fns & {
    type: string;
    serializeGuard: (value: unknown, ctx: BaseSerCtx<Fns>) => boolean;
};

// @public
export interface CustomHttpClientOptions {
    client: 'custom';
    fetcher: Fetcher;
}

// @public
export class DataAPIBlob implements TableCodec<typeof DataAPIBlob> {
    static [$DeserializeForTable](_: unknown, value: any, ctx: TableDesCtx): readonly [0, (DataAPIBlob | undefined)?];
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, ({
        $binary: string;
    } | undefined)?];
    constructor(blob: DataAPIBlobLike, validate?: boolean);
    asArrayBuffer(): ArrayBuffer;
    asBase64(): string;
    asBuffer(): MaybeBuffer;
    get byteLength(): number;
    static isBlobLike(value: unknown): value is DataAPIBlobLike;
    raw(): Exclude<DataAPIBlobLike, DataAPIBlob>;
    toString(): string;
}

// @public
export type DataAPIBlobLike = DataAPIBlob | ArrayBuffer | MaybeBuffer | {
    $binary: string;
};

// @public
export class DataAPIClient extends DataAPIClientEventEmitterBase {
    constructor(options?: DataAPIClientOptions | nullish);
    constructor(token: string | TokenProvider | nullish, options?: DataAPIClientOptions | nullish);
    admin(options?: AdminOptions): AstraAdmin;
    close(): Promise<void>;
    db(endpoint: string, options?: DbOptions): Db;
}

// @public
export abstract class DataAPIClientEvent {
    // @internal
    protected constructor(name: string);
    formatted(): string;
    // @internal
    static formattedPrefix(): string;
    readonly name: string;
}

// @public
export const DataAPIClientEventEmitterBase: new () => TypedEmitter<DataAPIClientEventMap>;

// @public
export type DataAPIClientEventMap = AdminCommandEventMap & CommandEventMap;

// @public
export interface DataAPIClientOptions {
    adminOptions?: RootAdminOptions;
    caller?: OneOrMany<Caller>;
    dbOptions?: RootDbOptions;
    environment?: DataAPIEnvironment;
    httpOptions?: DataAPIHttpOptions;
    logging?: DataAPILoggingConfig;
    timeoutDefaults?: Partial<TimeoutDescriptor>;
}

// @public
export interface DataAPICreateKeyspaceOptions extends WithTimeout<'keyspaceAdminTimeoutMs'> {
    // (undocumented)
    replication?: KeyspaceReplicationOptions;
    // (undocumented)
    updateDbKeyspace?: boolean;
}

// @public
export class DataAPIDate implements TableCodec<typeof DataAPIDate> {
    static [$DeserializeForTable](_: unknown, value: string, ctx: TableDesCtx): readonly [0, (DataAPIDate | undefined)?];
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (string | undefined)?];
    constructor(date: Date);
    constructor(date: string, strict?: boolean);
    constructor(year: number, month: number, date: number);
    compare(other: DataAPIDate): -1 | 0 | 1;
    readonly date: number;
    equals(other: DataAPIDate): boolean;
    readonly month: number;
    static now(): DataAPIDate;
    static ofEpochDay(epochDays: number): DataAPIDate;
    static ofYearDay(year: number, dayOfYear: number): DataAPIDate;
    toDate(base?: Date | DataAPITime): Date;
    toString(): string;
    static utcnow(): DataAPIDate;
    readonly year: number;
}

// @public
export class DataAPIDbAdmin extends DbAdmin {
    // @internal
    constructor(db: Db, httpClient: DataAPIHttpClient, rawAdminOpts?: AdminOptions);
    createKeyspace(keyspace: string, options?: DataAPICreateKeyspaceOptions): Promise<void>;
    db(): Db;
    dropKeyspace(keyspace: string, options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<void>;
    findEmbeddingProviders(options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<FindEmbeddingProvidersResult>;
    // (undocumented)
    get _httpClient(): OpaqueHttpClient;
    listKeyspaces(options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<string[]>;
}

// @public
export interface DataAPIDetailedErrorDescriptor {
    readonly command: Record<string, any>;
    readonly errorDescriptors: DataAPIErrorDescriptor[];
    readonly rawResponse: RawDataAPIResponse;
}

// @public
export class DataAPIDuration implements TableCodec<typeof DataAPIDuration> {
    static [$DeserializeForTable](_: unknown, value: any, ctx: TableDesCtx): readonly [0, (DataAPIDuration | undefined)?];
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (string | undefined)?];
    constructor(input: string);
    toString(): string;
}

// @public
export type DataAPIEnvironment = typeof DataAPIEnvironments[number];

// @public
export const DataAPIEnvironments: readonly ["astra", "dse", "hcd", "cassandra", "other"];

// @public
export abstract class DataAPIError extends Error {
}

// @public
export interface DataAPIErrorDescriptor {
    readonly attributes?: Record<string, any>;
    readonly errorCode?: string;
    readonly message?: string;
}

// @public
export interface DataAPIExplicitLoggingConfig {
    // (undocumented)
    readonly emits: OneOrMany<DataAPILoggingOutput>;
    // (undocumented)
    readonly events: OneOrMany<DataAPILoggingEvent>;
}

// @public
export class DataAPIHttpError extends DataAPIError {
    // @internal
    constructor(resp: FetcherResponseInfo);
    readonly body?: string;
    readonly raw: FetcherResponseInfo;
    readonly status: number;
}

// @public
export type DataAPIHttpOptions = DefaultHttpClientOptions | FetchHttpClientOptions | CustomHttpClientOptions;

// @public
export type DataAPILoggingConfig = DataAPILoggingEvent | readonly (DataAPILoggingEvent | DataAPIExplicitLoggingConfig)[];

// @public
export const DataAPILoggingDefaults: NormalizedLoggingConfig[];

// @public
export type DataAPILoggingEvent = 'all' | keyof DataAPIClientEventMap;

// @public
export type DataAPILoggingOutput = 'event' | 'stdout' | 'stderr';

// @public
export class DataAPIResponseError extends DataAPIError {
    // @internal
    constructor(detailedErrDescriptors: DataAPIDetailedErrorDescriptor[]);
    readonly detailedErrorDescriptors: DataAPIDetailedErrorDescriptor[];
    readonly errorDescriptors: DataAPIErrorDescriptor[];
    readonly message: string;
}

// @public
export class DataAPITime implements TableCodec<typeof DataAPITime> {
    static [$DeserializeForTable](_: unknown, value: any, ctx: TableDesCtx): readonly [0, (DataAPITime | undefined)?];
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (string | undefined)?];
    constructor(time: Date);
    constructor(time: string, strict?: boolean);
    constructor(hours: number, minutes: number, seconds?: number, nanoseconds?: number);
    compare(other: DataAPITime): -1 | 0 | 1;
    equals(other: DataAPITime | string): boolean;
    readonly hours: number;
    readonly minutes: number;
    readonly nanoseconds: number;
    static now(): DataAPITime;
    static ofNanoOfDay(nanoOfDay: number): DataAPITime;
    static ofSecondOfDay(secondOfDay: number): DataAPITime;
    readonly seconds: number;
    toDate(base?: Date | DataAPIDate): Date;
    toString(): string;
    static utcnow(): DataAPITime;
}

// @public
export class DataAPITimeoutError extends DataAPIError {
    // Warning: (ae-forgotten-export) The symbol "HTTPRequestInfo" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor(info: HTTPRequestInfo, types: TimedOutCategories);
    // @internal (undocumented)
    static mk(info: HTTPRequestInfo, types: TimedOutCategories): DataAPITimeoutError;
    // (undocumented)
    readonly timedOutTypes: TimedOutCategories;
    readonly timeout: Partial<TimeoutDescriptor>;
}

// @public
export class DataAPIVector implements CollCodec<typeof DataAPIVector>, TableCodec<typeof DataAPIVector> {
    static [$DeserializeForCollection](_: string, value: any, ctx: CollDesCtx): readonly [0, (DataAPIVector | undefined)?];
    static [$DeserializeForTable](_: unknown, value: any, ctx: TableDesCtx): readonly [0, (DataAPIVector | undefined)?];
    [$SerializeForCollection](ctx: CollSerCtx): readonly [0, any?];
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, any?];
    constructor(vector: DataAPIVectorLike, validate?: boolean);
    asArray(): number[];
    asBase64(): string;
    asFloat32Array(): Float32Array;
    static isVectorLike(value: unknown): value is DataAPIVectorLike;
    get length(): number;
    raw(): Exclude<DataAPIVectorLike, DataAPIVector>;
    toString(): string;
}

// @public
export type DataAPIVectorLike = number[] | {
    $binary: string;
} | Float32Array | DataAPIVector;

// @public
export const date: ((...params: [string] | [Date] | [number, number, number]) => DataAPIDate) & {
    now: typeof DataAPIDate.now;
    utcnow: typeof DataAPIDate.utcnow;
    ofEpochDay: typeof DataAPIDate.ofEpochDay;
    ofYearDay: typeof DataAPIDate.ofYearDay;
};

// @public
export class Db {
    // @internal
    constructor(rootOpts: InternalRootClientOpts, endpoint: string, rawDbOpts: DbOptions | nullish);
    admin(options?: AdminOptions & {
        environment?: 'astra';
    }): AstraDbAdmin;
    admin(options: AdminOptions & {
        environment: Exclude<DataAPIEnvironment, 'astra'>;
    }): DataAPIDbAdmin;
    collection<WSchema extends SomeDoc, RSchema extends WithId<SomeDoc> = FoundDoc<WSchema>>(name: string, options?: CollectionOptions): Collection<WSchema, RSchema>;
    command(command: Record<string, any>, options?: RunCommandOptions): Promise<RawDataAPIResponse>;
    createCollection<WSchema extends SomeDoc, RSchema extends WithId<SomeDoc> = FoundDoc<WSchema>>(name: string, options?: CreateCollectionOptions<WSchema>): Promise<Collection<WSchema, RSchema>>;
    createTable<const Def extends CreateTableDefinition>(name: string, options: CreateTableOptions<Def>): Promise<Table<InferTableSchema<Def>, InferTablePrimaryKey<Def>>>;
    createTable<WSchema extends SomeRow, PKeys extends SomeRow = Partial<FoundRow<WSchema>>, RSchema extends SomeRow = FoundRow<WSchema>>(name: string, options: CreateTableOptions): Promise<Table<WSchema, PKeys, RSchema>>;
    dropCollection(name: string, options?: DropCollectionOptions): Promise<void>;
    dropTable(name: string, options?: DropTableOptions): Promise<void>;
    dropTableIndex(name: string, options?: TableDropIndexOptions): Promise<void>;
    // (undocumented)
    get _httpClient(): OpaqueHttpClient;
    get id(): string;
    info(options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<AstraDbInfo>;
    get keyspace(): string;
    listCollections(options: ListCollectionsOptions & {
        nameOnly: true;
    }): Promise<string[]>;
    listCollections(options?: ListCollectionsOptions & {
        nameOnly?: false;
    }): Promise<CollectionDescriptor[]>;
    listTables(options: ListTablesOptions & {
        nameOnly: true;
    }): Promise<string[]>;
    listTables(options?: ListTablesOptions & {
        nameOnly?: false;
    }): Promise<TableDescriptor[]>;
    get region(): string;
    table<WSchema extends SomeRow, PKeys extends SomeRow = Partial<FoundRow<WSchema>>, RSchema extends SomeRow = FoundRow<WSchema>>(name: string, options?: TableOptions): Table<WSchema, PKeys, RSchema>;
    useKeyspace(keyspace: string): void;
}

// @public
export abstract class DbAdmin {
    abstract createKeyspace(keyspace: string, options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<void>;
    abstract db(): Db;
    abstract dropKeyspace(keyspace: string, options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<void>;
    abstract findEmbeddingProviders(options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<FindEmbeddingProvidersResult>;
    abstract listKeyspaces(options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<string[]>;
}

// @public
export interface DbOptions {
    additionalHeaders?: Record<string, string>;
    dataApiPath?: string;
    keyspace?: string | null;
    logging?: DataAPILoggingConfig;
    // @beta
    serdes?: DbSerDesConfig;
    timeoutDefaults?: Partial<TimeoutDescriptor>;
    token?: string | TokenProvider | null;
}

// @beta
export interface DbSerDesConfig {
    collection?: Omit<CollectionSerDesConfig, 'mutateInPlace'>;
    mutateInPlace?: boolean;
    table?: Omit<TableSerDesConfig, 'mutateInPlace'>;
}

// @public
export const DEFAULT_KEYSPACE = "default_keyspace";

// @public
export interface DefaultHttpClientOptions {
    client?: 'default';
    fetchH2?: unknown;
    http1?: Http1Options;
    preferHttp2?: boolean;
}

// @public
export abstract class DevOpsAPIError extends Error {
}

// @public
export interface DevOpsAPIErrorDescriptor {
    id: number;
    message?: string;
}

// @public
export class DevOpsAPIResponseError extends DevOpsAPIError {
    // @internal
    constructor(resp: FetcherResponseInfo, data: SomeDoc | undefined);
    readonly errors: DevOpsAPIErrorDescriptor[];
    readonly raw: FetcherResponseInfo;
    readonly status: number;
}

// @public
export class DevOpsAPITimeoutError extends DevOpsAPIError {
    // @internal
    constructor(info: HTTPRequestInfo, types: TimedOutCategories);
    // @internal (undocumented)
    static mk(info: HTTPRequestInfo, types: TimedOutCategories): DevOpsAPITimeoutError;
    // (undocumented)
    readonly timedOutTypes: TimedOutCategories;
    readonly timeout: Partial<TimeoutDescriptor>;
    readonly url: string;
}

// @public
export class DevOpsUnexpectedStateError extends DevOpsAPIError {
    // @internal
    constructor(message: string, expected: string[], data: SomeDoc | undefined);
    readonly dbInfo?: Record<string, any>;
    readonly expected: string[];
}

// @public
export interface DropCollectionOptions extends WithTimeout<'collectionAdminTimeoutMs'>, WithKeyspace {
}

// @public
export interface DropColumnOperation<Schema extends SomeRow> {
    columns: (keyof Schema)[];
}

// @public
export interface DropTableOptions extends WithTimeout<'tableAdminTimeoutMs'>, WithKeyspace {
    ifExists?: boolean;
}

// @public
export interface DropVectorizeOperation<Schema extends SomeRow> {
    columns: (keyof Schema)[];
}

// @public
export const duration: (duration: string) => DataAPIDuration;

// @public
export class EmbeddingAPIKeyHeaderProvider extends EmbeddingHeadersProvider {
    constructor(apiKey: string | nullish);
    getHeaders(): Record<string, string>;
}

// @public
export abstract class EmbeddingHeadersProvider {
    abstract getHeaders(): Promise<Record<string, string>> | Record<string, string>;
    // @internal
    static parseHeaders(token: unknown): EmbeddingHeadersProvider;
}

// @public
export interface EmbeddingProviderAuthInfo {
    enabled: boolean;
    tokens: EmbeddingProviderTokenInfo[];
}

// @public
export interface EmbeddingProviderInfo {
    displayName: string;
    models: EmbeddingProviderModelInfo[];
    parameters: EmbeddingProviderProviderParameterInfo[];
    supportedAuthentication: Record<string, EmbeddingProviderAuthInfo>;
    url: string;
}

// @public
export interface EmbeddingProviderModelInfo {
    name: string;
    parameters: EmbeddingProviderModelParameterInfo[];
    vectorDimension: number | null;
}

// @public
export interface EmbeddingProviderModelParameterInfo {
    defaultValue: string;
    help: string;
    name: string;
    required: boolean;
    type: string;
    validation: Record<string, unknown>[];
}

// @public
export interface EmbeddingProviderProviderParameterInfo extends EmbeddingProviderModelParameterInfo {
    displayName: string;
    hint: string;
}

// @public
export interface EmbeddingProviderTokenInfo {
    accepted: string;
    forwarded: string;
}

// @public
export type EmptyObj = {};

// @public
export class FailedToLoadDefaultClientError extends Error {
    // @internal
    constructor(rootCause: Error);
    readonly rootCause: Error;
}

// @public
export interface Fetcher {
    close?(): Promise<void>;
    fetch(info: FetcherRequestInfo): Promise<FetcherResponseInfo>;
}

// @public
export interface FetcherRequestInfo {
    body: string | undefined;
    forceHttp1: boolean | undefined;
    headers: Record<string, string>;
    method: 'DELETE' | 'GET' | 'POST';
    mkTimeoutError: () => Error;
    timeout: number;
    url: string;
}

// @public
export interface FetcherResponseInfo {
    additionalAttributes?: Record<string, any>;
    body?: string;
    headers: Record<string, string>;
    httpVersion: 1 | 2;
    status: number;
    statusText: string;
    url: string;
}

// @public
export class FetchH2 implements Fetcher {
    constructor(options: DefaultHttpClientOptions | undefined, preferHttp2: boolean);
    close(): Promise<void>;
    fetch(info: FetcherRequestInfo): Promise<FetcherResponseInfo>;
}

// @public
export interface FetchHttpClientOptions {
    client: 'fetch';
}

// @public
export class FetchNative implements Fetcher {
    close(): Promise<void>;
    fetch(info: FetcherRequestInfo): Promise<FetcherResponseInfo>;
}

// @public
export type Filter = Record<string, any>;

// @public
export abstract class FindCursor<T, TRaw extends SomeDoc = SomeDoc> {
    [Symbol.asyncIterator](): AsyncGenerator<T, void, void>;
    // Warning: (ae-forgotten-export) The symbol "SerDes" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor(parent: Table<SomeRow> | Collection, serdes: SerDes, filter: [Filter, boolean], options?: GenericFindOptions, mapping?: (doc: TRaw) => T);
    buffered(): number;
    clone(): FindCursor<TRaw, TRaw>;
    close(): void;
    consumeBuffer(max?: number): TRaw[];
    consumed(): number;
    get dataSource(): Table<SomeRow> | Collection;
    filter(filter: Filter): FindCursor<T, TRaw>;
    forEach(consumer: ((doc: T) => boolean) | ((doc: T) => void)): Promise<void>;
    getSortVector(): Promise<DataAPIVector | null>;
    hasNext(): Promise<boolean>;
    includeSimilarity(includeSimilarity?: boolean): FindCursor<WithSim<TRaw>, WithSim<TRaw>>;
    includeSortVector(includeSortVector?: boolean): FindCursor<T, TRaw>;
    limit(limit: number): FindCursor<T, TRaw>;
    map<R>(mapping: (doc: T) => R): FindCursor<R, TRaw>;
    next(): Promise<T | null>;
    project<RRaw extends SomeDoc = Partial<TRaw>>(projection: Projection): FindCursor<RRaw, RRaw>;
    rewind(): void;
    skip(skip: number): FindCursor<T, TRaw>;
    sort(sort: Sort): FindCursor<T, TRaw>;
    get state(): FindCursorStatus;
    toArray(): Promise<T[]>;
}

// @public
export type FindCursorStatus = 'idle' | 'started' | 'closed';

// @public
export interface FindEmbeddingProvidersResult {
    embeddingProviders: Record<string, EmbeddingProviderInfo>;
}

// @public
export type Flatten<Type> = Type extends (infer Item)[] ? Item : Type;

// @public
export type FoundDoc<Doc> = WithId<Omit<Doc, '$vector' | '$vectorize'>>;

// @public
export type FoundRow<Doc> = {
    [K in keyof Doc]-?: DataAPIVector extends Doc[K] ? Exclude<Doc[K], string> : Doc[K];
};

// @public
export interface FullCreateTablePrimaryKeyDefinition {
    // (undocumented)
    readonly partitionBy: readonly string[];
    // (undocumented)
    readonly partitionSort?: Record<string, 1 | -1>;
}

// @public
export interface GenericDeleteManyResult {
    deletedCount: number;
}

// @public
export interface GenericDeleteOneOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    // (undocumented)
    sort?: Sort;
}

// @public
export interface GenericDeleteOneResult {
    // (undocumented)
    deletedCount: 0 | 1;
}

// @public
export interface GenericFindOneAndDeleteOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    projection?: Projection;
    sort?: Sort;
}

// @public
export interface GenericFindOneAndReplaceOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    projection?: Projection;
    returnDocument?: 'before' | 'after';
    sort?: Sort;
    upsert?: boolean;
}

// @public
export interface GenericFindOneAndUpdateOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    projection?: Projection;
    returnDocument?: 'before' | 'after';
    sort?: Sort;
    upsert?: boolean;
}

// @public
export interface GenericFindOneOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    includeSimilarity?: boolean;
    projection?: Projection;
    sort?: Sort;
}

// @public
export interface GenericFindOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    includeSimilarity?: boolean;
    includeSortVector?: boolean;
    limit?: number;
    projection?: Projection;
    skip?: number;
    sort?: Sort;
}

// @public
export type GenericInsertManyOptions = GenericInsertManyUnorderedOptions | GenericInsertManyOrderedOptions;

// @public
export interface GenericInsertManyOrderedOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    chunkSize?: number;
    ordered: true;
}

// @public
export interface GenericInsertManyUnorderedOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    chunkSize?: number;
    concurrency?: number;
    ordered?: false;
}

// @public
export interface GenericReplaceOneOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    // (undocumented)
    sort?: Sort;
    // (undocumented)
    upsert?: boolean;
}

// @public
export interface GenericUpdateManyOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    // (undocumented)
    upsert?: boolean;
}

// @public
export interface GenericUpdateOneOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    sort?: Sort;
    upsert?: boolean;
}

// @public
export type GenericUpdateResult<ID, N extends number> = (GuaranteedUpdateResult<N> & UpsertedUpdateResult<ID>) | (GuaranteedUpdateResult<N> & NoUpsertUpdateResult);

// @public (undocumented)
export type GetCollNumRepFn = (path: readonly string[]) => CollNumRep;

// @public
export interface GuaranteedUpdateResult<N extends number> {
    matchedCount: N;
    modifiedCount: N;
}

// @public
export interface Http1Options {
    keepAlive?: boolean;
    keepAliveMS?: number;
    maxFreeSockets?: number;
    maxSockets?: number;
}

// @public
export type IdOf<Doc> = Doc extends {
    _id?: infer Id extends SomeId;
} ? Id : SomeId;

// @public
export type InferrableTable = CreateTableDefinition | ((..._: any[]) => Promise<Table<SomeRow>>) | ((..._: any[]) => Table<SomeRow>) | Promise<Table<SomeRow>> | Table<SomeRow>;

// Warning: (ae-forgotten-export) The symbol "InferTablePKFromDefinition" needs to be exported by the entry point index.d.ts
//
// @public
export type InferTablePrimaryKey<T extends InferrableTable> = T extends CreateTableDefinition ? InferTablePKFromDefinition<T> : T extends (..._: any[]) => Promise<Table<any, infer PKey, any>> ? PKey : T extends (..._: any[]) => Table<any, infer PKey, any> ? PKey : T extends Promise<Table<any, infer PKey, any>> ? PKey : T extends Table<any, infer PKey, any> ? PKey : never;

// Warning: (ae-forgotten-export) The symbol "InferTableSchemaFromDefinition" needs to be exported by the entry point index.d.ts
//
// @public
export type InferTableReadSchema<T extends InferrableTable> = T extends CreateTableDefinition ? FoundRow<InferTableSchemaFromDefinition<T>> : T extends (..._: any[]) => Promise<Table<any, any, infer Schema>> ? Schema : T extends (..._: any[]) => Table<any, any, infer Schema> ? Schema : T extends Promise<Table<any, any, infer Schema>> ? Schema : T extends Table<any, any, infer Schema> ? Schema : never;

// @public
export type InferTableSchema<T extends InferrableTable> = T extends CreateTableDefinition ? InferTableSchemaFromDefinition<T> : T extends (..._: any[]) => Promise<Table<infer Schema, any, any>> ? Schema : T extends (..._: any[]) => Table<infer Schema, any, any> ? Schema : T extends Promise<Table<infer Schema, any, any>> ? Schema : T extends Table<infer Schema, any, any> ? Schema : never;

// @public
export class InvalidEnvironmentError extends Error {
    // @internal
    constructor(operation: string, currentEnvironment: string, expectedEnvironments: string[], extra?: string);
    readonly currentEnvironment: string;
    readonly expectedEnvironments: string[];
}

// @public
export type KeyspaceReplicationOptions = {
    class: 'SimpleStrategy';
    replicationFactor: number;
} | {
    class: 'NetworkTopologyStrategy';
    [datacenter: string]: number | 'NetworkTopologyStrategy';
};

// @public (undocumented)
export abstract class KeyTransformer {
    // (undocumented)
    abstract deserializeKey(key: string, ctx: BaseDesCtx<CodecSerDesFns>): string;
    // (undocumented)
    abstract serializeKey(key: string, ctx: BaseSerCtx<CodecSerDesFns>): string;
}

// @public
export const LIB_NAME = "astra-db-ts";

// @public
export const LIB_VERSION = "2.0.0-preview.0";

// @public
export interface ListAstraDatabasesOptions extends WithTimeout<'databaseAdminTimeoutMs'> {
    include?: AstraDbStatusFilter;
    limit?: number;
    provider?: AstraDbCloudProviderFilter;
    skip?: number;
}

// @public
export interface ListCollectionsOptions extends WithTimeout<'collectionAdminTimeoutMs'>, WithKeyspace {
    nameOnly?: boolean;
}

// @public
export interface ListCreateTableColumnDefinition {
    // (undocumented)
    type: 'list';
    // (undocumented)
    valueType: TableScalarType;
}

// @public
export interface ListIndexOptions extends WithTimeout<'tableAdminTimeoutMs'> {
    // (undocumented)
    nameOnly?: boolean;
}

// @public
export type ListTableColumnDefinitions = Record<string, ListTableKnownColumnDefinition | ListTableUnsupportedColumnDefinition>;

// @public
export interface ListTableDefinition {
    // (undocumented)
    columns: ListTableColumnDefinitions;
    // (undocumented)
    primaryKey: ListTablePrimaryKeyDefinition;
}

// @public
export type ListTableKnownColumnDefinition = StrictCreateTableColumnDefinition & {
    apiSupport?: ListTableUnsupportedColumnApiSupport;
};

// @public
export type ListTablePrimaryKeyDefinition = Required<FullCreateTablePrimaryKeyDefinition>;

// @public
export interface ListTablesOptions extends WithTimeout<'tableAdminTimeoutMs'>, WithKeyspace {
    nameOnly?: boolean;
}

// @public
export interface ListTableUnsupportedColumnApiSupport {
    // (undocumented)
    cqlDefinition: string;
    // (undocumented)
    createTable: boolean;
    // (undocumented)
    filter: boolean;
    // (undocumented)
    insert: boolean;
    // (undocumented)
    read: boolean;
}

// @public
export interface ListTableUnsupportedColumnDefinition {
    // (undocumented)
    apiSupport: ListTableUnsupportedColumnApiSupport;
    // (undocumented)
    type: 'UNSUPPORTED';
}

// @public
export type LooseCreateTableColumnDefinition = TableScalarType | string;

// @public
export interface MapCreateTableColumnDefinition {
    // (undocumented)
    keyType: 'text' | 'ascii';
    // (undocumented)
    type: 'map';
    // (undocumented)
    valueType: TableScalarType;
}

// @public
export type MaybeBuffer = typeof globalThis extends {
    Buffer: infer B extends abstract new (...args: any) => any;
} ? InstanceType<B> : never;

// @public
export type MaybeId<T> = NoId<T> & {
    _id?: IdOf<T>;
};

// @public (undocumented)
export type NameCodec<Fns extends CodecSerDesFns> = {
    serialize?: Fns['serialize'];
    deserialize: Fns['deserialize'];
} & {
    name: string;
};

// @public
export type NoId<Doc> = Omit<Doc, '_id'>;

// @public
export type Normalize<T> = {
    [K in keyof T]: T[K];
} & EmptyObj;

// @public (undocumented)
export interface NormalizedLoggingConfig {
    // (undocumented)
    emits: readonly DataAPILoggingOutput[];
    // (undocumented)
    events: readonly DataAPILoggingEvent[];
}

// @public
export interface NoUpsertUpdateResult {
    upsertedCount: 0;
    upsertedId?: never;
}

// @public
export type nullish = null | undefined;

// @public (undocumented)
export class NumCoercionError extends Error {
    // @internal
    constructor(path: string[], value: number | BigNumber, from: 'number' | 'bignumber', to: CollNumRep);
    // (undocumented)
    readonly from: 'number' | 'bignumber';
    // (undocumented)
    readonly path: string[];
    // (undocumented)
    readonly to: CollNumRep;
    // (undocumented)
    readonly value: number | BigNumber;
}

// @public
export class ObjectId implements CollCodec<typeof ObjectId> {
    static [$DeserializeForCollection](_: string, value: any, ctx: CollDesCtx): readonly [0, (ObjectId | undefined)?];
    [$SerializeForCollection](ctx: CollSerCtx): readonly [0, ({
        $objectId: string;
    } | undefined)?];
    constructor(id?: string | number | null, validate?: boolean);
    equals(other: unknown): boolean;
    getTimestamp(): Date;
    toString(): string;
}

// @public
export const oid: (id?: string | number | null) => ObjectId;

// @public
export type OneOrMany<T> = T | readonly T[];

// @public
export type OpaqueHttpClient = any;

// @public (undocumented)
export type PathCodec<Fns extends CodecSerDesFns> = {
    serialize?: Fns['serialize'];
    deserialize: Fns['deserialize'];
} & {
    path: string[];
};

// @public
export type Projection = Record<string, 1 | 0 | boolean | ProjectionSlice>;

// @public
export interface ProjectionSlice {
    $slice: number | [number, number];
}

// @public (undocumented)
export type RawCodec<Fns extends CodecSerDesFns> = ({
    path: string[];
} | {
    name: string;
} | {
    type: string;
}) & CodecOpts<Fns, unknown, unknown>;

// @public
export interface RawDataAPIResponse {
    data?: Record<string, any>;
    errors?: any[];
    status?: Record<string, any>;
}

// @public
export type RootAdminOptions = Omit<AdminOptions, 'logging' | 'timeoutDefaults'>;

// @public
export type RootDbOptions = Omit<DbOptions, 'logging' | 'timeoutDefaults'>;

// @public
export interface RunCommandOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    collection?: string;
    keyspace?: string | null;
    // (undocumented)
    table?: string;
}

// @public
export interface ScalarCreateTableColumnDefinition {
    // (undocumented)
    type: TableScalarType;
}

// @public (undocumented)
export type SerDesFn<Ctx> = (key: string, value: any, ctx: Ctx) => readonly [0 | 1 | 2, any?] | 'Return ctx.done(val?), ctx.recurse(val?), ctx.continue(), or void';

// @public
export interface SetCreateTableColumnDefinition {
    // (undocumented)
    type: 'set';
    // (undocumented)
    valueType: TableScalarType;
}

// @public (undocumented)
export type SomeCodec<Fns extends CodecSerDesFns> = NameCodec<Fns> | PathCodec<Fns> | TypeCodec<Fns> | CustomGuardCodec<Fns> | ClassGuardCodec<Fns>;

// @public
export type SomeDoc = Record<string, any>;

// @public
export type SomeId = string | number | bigint | boolean | Date | UUID | ObjectId | null;

// @public
export type SomeRow = Record<string, any>;

// @public
export type Sort = Record<string, SortDirection | number[] | DataAPIVector | string>;

// @public
export type SortDirection = 1 | -1;

// @public
export class StaticTokenProvider extends TokenProvider {
    constructor(token: string);
    getToken(): string;
}

// @public
export type StrictCreateTableColumnDefinition = ScalarCreateTableColumnDefinition | MapCreateTableColumnDefinition | ListCreateTableColumnDefinition | SetCreateTableColumnDefinition | VectorCreateTableColumnDefinition;

// @public
export class Table<WSchema extends SomeRow, PKey extends SomeRow = Partial<FoundRow<WSchema>>, RSchema extends SomeRow = FoundRow<WSchema>> {
    // @internal
    constructor(db: Db, httpClient: DataAPIHttpClient, name: string, opts: TableOptions | undefined);
    alter<NewWSchema extends SomeRow, NewRSchema extends SomeRow = FoundRow<NewWSchema>>(options: AlterTableOptions<SomeRow>): Promise<Table<NewWSchema, PKey, NewRSchema>>;
    createIndex(name: string, column: WSchema | string, options?: CreateTableIndexOptions): Promise<void>;
    createVectorIndex(name: string, column: WSchema | string, options?: CreateTableVectorIndexOptions): Promise<void>;
    definition(options?: WithTimeout<'tableAdminTimeoutMs'>): Promise<ListTableDefinition>;
    deleteMany(filter: TableFilter<WSchema>, timeout?: WithTimeout<'generalMethodTimeoutMs'>): Promise<void>;
    deleteOne(filter: TableFilter<WSchema>, timeout?: WithTimeout<'generalMethodTimeoutMs'>): Promise<void>;
    drop(options?: Omit<DropTableOptions, 'keyspace'>): Promise<void>;
    find(filter: TableFilter<WSchema>, options?: TableFindOptions & {
        projection?: never;
    }): TableFindCursor<WithSim<RSchema>, WithSim<RSchema>>;
    find<TRaw extends SomeRow = Partial<RSchema>>(filter: TableFilter<WSchema>, options: TableFindOptions): TableFindCursor<TRaw, TRaw>;
    findOne(filter: TableFilter<WSchema>, options?: TableFindOneOptions & {
        projection?: never;
    }): Promise<WithSim<RSchema> | null>;
    findOne<TRaw extends SomeRow = Partial<RSchema>>(filter: TableFilter<WSchema>, options: TableFindOneOptions): Promise<TRaw | null>;
    get _httpClient(): OpaqueHttpClient;
    insertMany(rows: readonly WSchema[], options?: TableInsertManyOptions): Promise<TableInsertManyResult<PKey>>;
    insertOne(row: WSchema, timeout?: WithTimeout<'generalMethodTimeoutMs'>): Promise<TableInsertOneResult<PKey>>;
    readonly keyspace: string;
    listIndexes(options: ListIndexOptions & {
        nameOnly: true;
    }): Promise<string[]>;
    listIndexes(options?: ListIndexOptions & {
        nameOnly?: false;
    }): Promise<TableIndexDescriptor[]>;
    readonly name: string;
    updateOne(filter: TableFilter<WSchema>, update: TableUpdateFilter<WSchema>, timeout?: WithTimeout<'generalMethodTimeoutMs'>): Promise<void>;
}

// @public (undocumented)
export type TableCodec<_Class extends TableCodecClass> = EmptyObj;

// @public (undocumented)
export type TableCodecClass = {
    new (...args: any[]): {
        [$SerializeForTable]: (ctx: TableSerCtx) => ReturnType<SerDesFn<any>>;
    };
    [$DeserializeForTable]: TableCodecSerDesFns['deserialize'];
};

// @public (undocumented)
export class TableCodecs {
    // (undocumented)
    static Defaults: {
        bigint: RawCodec<TableCodecSerDesFns>;
        blob: RawCodec<TableCodecSerDesFns>;
        counter: RawCodec<TableCodecSerDesFns>;
        date: RawCodec<TableCodecSerDesFns>;
        decimal: RawCodec<TableCodecSerDesFns>;
        double: RawCodec<TableCodecSerDesFns>;
        duration: RawCodec<TableCodecSerDesFns>;
        float: RawCodec<TableCodecSerDesFns>;
        time: RawCodec<TableCodecSerDesFns>;
        timestamp: RawCodec<TableCodecSerDesFns>;
        timeuuid: RawCodec<TableCodecSerDesFns>;
        uuid: RawCodec<TableCodecSerDesFns>;
        vector: RawCodec<TableCodecSerDesFns>;
        varint: RawCodec<TableCodecSerDesFns>;
        map: RawCodec<TableCodecSerDesFns>;
        list: RawCodec<TableCodecSerDesFns>;
        set: RawCodec<TableCodecSerDesFns>;
    };
    // (undocumented)
    static forName(name: string, optsOrClass: CodecOpts<TableCodecSerDesFns, TableSerCtx, TableDesCtx> | TableCodecClass): RawCodec<TableCodecSerDesFns>;
    // (undocumented)
    static forPath(path: string[], optsOrClass: CodecOpts<TableCodecSerDesFns, TableSerCtx, TableDesCtx> | TableCodecClass): RawCodec<TableCodecSerDesFns>;
    // (undocumented)
    static forType(type: string, optsOrClass: CodecOpts<TableCodecSerDesFns, TableSerCtx, TableDesCtx> | TableCodecClass): RawCodec<TableCodecSerDesFns>;
}

// @public (undocumented)
export interface TableCodecSerDesFns {
    // (undocumented)
    deserialize: (key: string | undefined, val: any, ctx: TableDesCtx, definition?: SomeDoc) => ReturnType<SerDesFn<any>>;
    // (undocumented)
    serialize: SerDesFn<TableSerCtx>;
}

// @public (undocumented)
export type TableColumnTypeParser = (val: any, ctx: TableDesCtx, definition: SomeDoc) => any;

// @public
export interface TableDescriptor {
    definition: ListTableDefinition;
    name: string;
}

// @public (undocumented)
export interface TableDesCtx extends BaseDesCtx<TableCodecSerDesFns> {
    // (undocumented)
    next: never;
    // (undocumented)
    populateSparseData: boolean;
    // (undocumented)
    tableSchema: ListTableColumnDefinitions;
}

// @public
export interface TableDropIndexOptions extends WithKeyspace, WithTimeout<'tableAdminTimeoutMs'> {
    ifExists?: boolean;
}

// @public
export type TableFilter<Schema extends SomeRow> = {
    [K in keyof Schema]?: TableFilterExpr<Schema[K]>;
} & {
    $and?: TableFilter<Schema>[];
    $or?: TableFilter<Schema>[];
    $not?: TableFilter<Schema>;
    [key: string]: any;
};

// @public
export type TableFilterExpr<Elem> = Elem | TableFilterOps<Elem>;

// @public
export type TableFilterOps<Elem> = {
    $eq?: Elem;
    $ne?: Elem;
    $in?: Elem[];
    $nin?: Elem[];
    $exists?: boolean;
    $lt?: Elem;
    $lte?: Elem;
    $gt?: Elem;
    $gte?: Elem;
};

// @public
export class TableFindCursor<T, TRaw extends SomeDoc = SomeDoc> extends FindCursor<T, TRaw> {
    get dataSource(): Table<SomeRow>;
    filter(filter: TableFilter<TRaw>): FindCursor<T, TRaw>;
}

// @public
export type TableFindOneOptions = GenericFindOneOptions;

// @public
export type TableFindOptions = GenericFindOptions;

// @public
export interface TableIndexDescriptor {
    // (undocumented)
    definition: TableNormalIndexDescriptor | TableVectorIndexDescriptor | TableUnknownIndex;
    // (undocumented)
    name: string;
}

// @public
export interface TableIndexOptions {
    ascii?: boolean;
    caseSensitive?: boolean;
    normalize?: boolean;
}

// @public
export interface TableIndexUnsupportedColumnApiSupport {
    // (undocumented)
    cqlDefinition: string;
    // (undocumented)
    createIndex: boolean;
    // (undocumented)
    filter: boolean;
}

// @public
export class TableInsertManyError extends CumulativeOperationError {
    name: string;
    readonly partialResult: TableInsertManyResult<SomeDoc>;
}

// @public
export type TableInsertManyOptions = GenericInsertManyOptions;

// @public
export interface TableInsertManyResult<PKey extends SomeRow> {
    insertedCount: number;
    insertedIds: PKey[];
}

// @public
export interface TableInsertOneResult<PKey extends SomeRow> {
    insertedId: PKey;
}

// @public
export interface TableNormalIndexDescriptor {
    // (undocumented)
    column: string;
    // (undocumented)
    options: TableIndexOptions;
}

// @public
export interface TableOptions extends WithKeyspace {
    embeddingApiKey?: string | EmbeddingHeadersProvider | null;
    logging?: DataAPILoggingConfig;
    // @beta
    serdes?: TableSerDesConfig;
    timeoutDefaults?: Partial<TimeoutDescriptor>;
}

// @public
export type TableScalarType = 'ascii' | 'bigint' | 'blob' | 'boolean' | 'date' | 'decimal' | 'double' | 'duration' | 'float' | 'int' | 'inet' | 'smallint' | 'text' | 'time' | 'timestamp' | 'tinyint' | 'uuid' | 'varint';

// @public (undocumented)
export interface TableSerCtx extends BaseSerCtx<TableCodecSerDesFns> {
    // (undocumented)
    bigNumsPresent: boolean;
}

// @public (undocumented)
export interface TableSerDesConfig extends BaseSerDesConfig<TableCodecSerDesFns, TableSerCtx, TableDesCtx> {
    // (undocumented)
    codecs?: RawCodec<TableCodecSerDesFns>[];
    // (undocumented)
    sparseData?: boolean;
}

// @public
export interface TableUnknownIndex {
    // (undocumented)
    apiSupport: TableIndexUnsupportedColumnApiSupport;
    // (undocumented)
    column: 'UNKNOWN';
}

// @public
export interface TableUpdateFilter<Schema extends SomeRow> {
    $set?: Partial<Schema> & SomeRow;
    $unset?: Record<string, '' | true | 1>;
}

// @public
export interface TableVectorIndexDescriptor {
    // (undocumented)
    column: string;
    // (undocumented)
    options: TableVectorIndexOptions;
}

// @public
export interface TableVectorIndexOptions {
    metric?: 'cosine' | 'euclidean' | 'dot_product';
    sourceModel?: string | 'other';
}

// @public
export const time: ((...params: [string] | [Date] | [number, number, number?, number?]) => DataAPITime) & {
    now: typeof DataAPITime.now;
    utcnow: typeof DataAPITime.utcnow;
    ofNanoOfDay: typeof DataAPITime.ofNanoOfDay;
    ofSecondOfDay: typeof DataAPITime.ofSecondOfDay;
};

// @public
export type TimedOutCategories = OneOrMany<keyof TimeoutDescriptor> | 'provided';

// @public
export interface TimeoutDescriptor {
    collectionAdminTimeoutMs: number;
    databaseAdminTimeoutMs: number;
    generalMethodTimeoutMs: number;
    keyspaceAdminTimeoutMs: number;
    requestTimeoutMs: number;
    tableAdminTimeoutMs: number;
}

// Warning: (ae-forgotten-export) The symbol "Merge" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "_ToDotNotation" needs to be exported by the entry point index.d.ts
//
// @public
export type ToDotNotation<Schema extends SomeDoc> = Merge<_ToDotNotation<Schema, ''>>;

// @public
export abstract class TokenProvider {
    abstract getToken(): string | nullish | Promise<string | nullish>;
    // @internal
    static mergeTokens(...raw: (string | TokenProvider | nullish)[]): TokenProvider | undefined;
}

// @public
export class TooManyDocumentsToCountError extends DataAPIError {
    // @internal
    constructor(limit: number, hitServerLimit: boolean);
    readonly hitServerLimit: boolean;
    readonly limit: number;
}

// @public
export class TooManyRowsToCountError extends DataAPIError {
    // @internal
    constructor(limit: number, hitServerLimit: boolean);
    readonly hitServerLimit: boolean;
    readonly limit: number;
}

// @public (undocumented)
export type TypeCodec<Fns extends CodecSerDesFns> = Pick<Fns, 'deserialize'> & {
    type: string;
};

// @public
export class UnexpectedDataAPIResponseError extends Error {
    // @internal
    constructor(message: string, rawDataAPIResponse: unknown);
    readonly rawDataAPIResponse?: unknown;
    // (undocumented)
    static require<T>(val: T | null | undefined, message: string, rawDataAPIResponse?: unknown): T;
}

// @public
export type UpdateFilter = Record<string, any>;

// @public
export interface UpsertedUpdateResult<ID> {
    upsertedCount: 1;
    upsertedId: ID;
}

// @public
export class UsernamePasswordTokenProvider extends TokenProvider {
    constructor(username: string, password: string);
    getToken(): string;
}

// @public
export class UUID implements CollCodec<typeof UUID>, TableCodec<typeof UUID> {
    static [$DeserializeForCollection](_: string, value: any, ctx: CollDesCtx): readonly [0, (UUID | undefined)?];
    static [$DeserializeForTable](_: unknown, value: any, ctx: TableDesCtx): readonly [0, (UUID | undefined)?];
    [$SerializeForCollection](ctx: CollSerCtx): readonly [0, ({
        $uuid: string;
    } | undefined)?];
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (string | undefined)?];
    constructor(uuid: string, validate?: boolean, version?: number);
    equals(other: unknown): boolean;
    getTimestamp(): Date | undefined;
    toString(): string;
    static v1(msecs?: number, nsecs?: number): UUID;
    static v4(): UUID;
    static v6(msecs?: number, nsecs?: number): UUID;
    static v7(msecs?: number): UUID;
    readonly version: number;
}

// @public
export const uuid: (uuid: string | 1 | 4 | 6 | 7) => UUID;

// @public
export const vector: (v: DataAPIVectorLike) => DataAPIVector;

// @public
export interface VectorCreateTableColumnDefinition {
    // (undocumented)
    dimension: number;
    // (undocumented)
    service?: VectorizeServiceOptions;
    // (undocumented)
    type: 'vector';
}

// @public
export interface VectorDoc {
    $vector?: DataAPIVector;
}

// @public
export interface VectorizeDoc extends VectorDoc {
    $vectorize?: string;
}

// @public
export interface VectorizeServiceOptions {
    authentication?: Record<string, string | undefined>;
    modelName: string | nullish;
    parameters?: Record<string, unknown>;
    provider: string;
}

// @public
export type WithId<T> = T & {
    _id: IdOf<T>;
};

// @public
export interface WithKeyspace {
    keyspace?: string;
}

// @public
export type WithSim<Schema extends SomeDoc> = Schema & {
    $similarity?: number;
};

// @public
export interface WithTimeout<Timeouts extends keyof TimeoutDescriptor> {
    timeout?: number | Pick<Partial<TimeoutDescriptor>, 'requestTimeoutMs' | Timeouts>;
}


export * from "bignumber.js";

// (No @packageDocumentation comment for this package)

```
